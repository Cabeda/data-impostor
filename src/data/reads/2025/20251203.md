---
pubDate: 2025-12-03
---

##### [Anthropic acquires Bun by Simon Willison](https://simonwillison.net/2025/Dec/2/anthropic-acquires-bun/)
##### [Amazon S3 Tables now offer the Intelligent-Tiering storage class](https://aws.amazon.com/about-aws/whats-new/2025/12/s3-tables-intelligent-tiering-storage-class/)
##### [Benchmarking read latency of AWS S3, S3 Express, EBS and Instance store by Roman Grebennikov](https://nixiesearch.substack.com/p/benchmarking-read-latency-of-aws)
##### [10 Smart Performance Hacks For Faster Python Code | The PyCharm Blog by Evgenia Verbina](https://blog.jetbrains.com/pycharm/2025/11/10-smart-performance-hacks-for-faster-python-code/?featured_on=pythonbytes)

- Hack 2: Avoid unnecessary copies



Copying large objects like lists, dictionaries, or arrays can be costly in both time and memory. Each copy creates a new object in memory, which can lead to significant overhead, especially when working with large datasets or within tight loops.
- Hack 4: Use math functions instead of operators



For numerical computations, Python’s math module provides functions that are implemented in C, offering better performance and precision than equivalent operations written in pure Python.
- Hack 6: Avoid exception handling in hot loops



While Python’s exception handling is powerful and clean for managing unexpected behavior, it’s not designed for high-frequency use inside performance-critical loops. Raising and catching exceptions involves stack unwinding and context switching, which are relatively expensive operations
- Hack 9: Use bisect for sorted list operations



When working with sorted lists, using linear search or manual insertion logic can be inefficient – especially as the list grows. Python’s bisect module provides fast, efficient tools for maintaining sorted order using binary search.
- Hack 10: Avoid repeated function calls in loops



Calling the same function multiple times inside a loop – especially if the function is expensive or produces the same result each time – can lead to unnecessary overhead. Even relatively fast functions can accumulate significant cost when called repeatedly in large loops.
